#pragma once

#include "tema2/propeller.h"
#include "tema2/utils/pidcontroller.h"

#include <unordered_map>

namespace tema2
{
    class Drone
    {

    public:
        Drone(std::string name, Shader *shader)
            : name(name), shader(shader)
        {
            body = new RectangularPrism(name + "_body", shader);
            body->ComputeMesh();
            body->SetColor(glm::vec3(0.3f));

            arm1 = new RectangularPrism(name + "_arm1", shader);
            arm1->ComputeMesh();
            arm1->SetColor(glm::vec3(0.7f));

            arm2 = new RectangularPrism(name + "_arm2", shader);
            arm2->ComputeMesh();
            arm2->SetColor(glm::vec3(0.7f));

            propeller1 = new Propeller(name + "_propeller1", shader);
            propeller2 = new Propeller(name + "_propeller2", shader);
            propeller3 = new Propeller(name + "_propeller3", shader);
            propeller4 = new Propeller(name + "_propeller4", shader);

            activeForces["Gravity"] = glm::vec3(0.0f, -gravity, 0.0f);

            rollC = new PIDController(0.1f, 0.0f, 0.0f, 0.0f);
            pitchC = new PIDController(0.1f, 0.0f, 0.0f, 0.0f);

            minimapIndicator = new RectangularPrism("indicator", shader);
            minimapIndicator->ComputeMesh();
            minimapIndicator->SetColor(glm::vec3(1.0f, 0.0f, 0.0f));
        }

        ~Drone()
        {
            delete body;
            delete arm1;
            delete arm2;
            delete propeller1;
            delete propeller2;
            delete propeller3;
            delete propeller4;
        }

        glm::vec3 ComputeMotorForces()
        {
            float totalThrust = motor1Thrust + motor2Thrust + motor3Thrust + motor4Thrust;

            glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
            glm::vec3 thrustDirection = orientation * up;
            return totalThrust * thrustDirection;
        }

        void RenderIndicator(gfxc::Camera *camera, glm::vec3 pos)
        {
            glm::mat4 transform = glm::mat4(1.0f);
            transform = glm::translate(transform, pos);
            transform = glm::scale(transform, glm::vec3(10.0f));
            minimapIndicator->SetTransform(transform);
            minimapIndicator->Render(camera);
        }

        void Update(float deltaTimeSeconds)
        {
            // Compute the thrust needed to hover against gravity
            glm::vec3 localUp = orientation * glm::vec3(0.0f, 1.0f, 0.0f);
            float hoverThrustNeeded = mass * gravity / glm::dot(localUp, glm::vec3(0.0f, 1.0f, 0.0f));

            motor1Thrust = hoverThrustNeeded / 4.0f;
            motor2Thrust = hoverThrustNeeded / 4.0f;
            motor3Thrust = hoverThrustNeeded / 4.0f;
            motor4Thrust = hoverThrustNeeded / 4.0f;

            // If we are going up or down, give some extra thrust
            float extraThrust = (hoverThrustNeeded / 4.0f) * 0.40f;
            motor1Thrust += extraThrust * verticalDirection;
            motor2Thrust += extraThrust * verticalDirection;
            motor3Thrust += extraThrust * verticalDirection;
            motor4Thrust += extraThrust * verticalDirection;

            // Compute the force generated by the motors
            glm::vec3 motorForce = ComputeMotorForces();

            activeForces["MotorForces"] = motorForce;
            activeForces["Drag"] = -vel * 200.0f * deltaTimeSeconds;

            glm::vec3 netForce = glm::vec3(0.0f);
            for (auto f : activeForces)
                netForce += f.second;

            glm::vec3 acc = netForce / mass;

            // Runge-Kutta 4th order system, better than Euler Method
            glm::vec3 k1_vel = acc * deltaTimeSeconds;
            glm::vec3 k1_pos = vel * deltaTimeSeconds;

            glm::vec3 k2_vel = (acc + 0.5f * k1_vel) * deltaTimeSeconds;
            glm::vec3 k2_pos = (vel + 0.5f * k1_pos) * deltaTimeSeconds;

            glm::vec3 k3_vel = (acc + 0.5f * k2_vel) * deltaTimeSeconds;
            glm::vec3 k3_pos = (vel + 0.5f * k2_pos) * deltaTimeSeconds;

            glm::vec3 k4_vel = (acc + k3_vel) * deltaTimeSeconds;
            glm::vec3 k4_pos = (vel + k3_pos) * deltaTimeSeconds;

            vel += (1.0f / 6.0f) * (k1_vel + 2.0f * k2_vel + 2.0f * k3_vel + k4_vel);
            pos += (1.0f / 6.0f) * (k1_pos + 2.0f * k2_pos + 2.0f * k3_pos + k4_pos);

            // Clamp the height at 100 units
            if (pos.y > 100.0f)
                pos.y = 100.f;

            propeller1->Update(deltaTimeSeconds);
            propeller2->Update(deltaTimeSeconds);
            propeller3->Update(deltaTimeSeconds);
            propeller4->Update(deltaTimeSeconds);

            if (!rolling && !pitching && !yawing)
            {
                glm::vec3 ypr = GetYPR();
                float yaw = ypr.x;
                float pitch = ypr.y;
                float roll = ypr.z;

                // Apply corrections from the PID controller
                float correction = rollC->update(roll);
                RotateRoll(correction);

                correction = pitchC->update(pitch);
                RotatePitch(correction);
            }
        }

        void Render(gfxc::Camera *camera)
        {
            transform = glm::translate(glm::mat4(1.0f), pos);
            transform *= glm::toMat4(orientation);

            body->SetTransform(this->transform * glm::scale(glm::mat4(1.0f), glm::vec3(0.7f, 0.5f, 1.0f)));
            body->Render(camera);

            glm::mat4 t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm1->SetTransform(this->transform * t);
            arm1->Render(camera);

            t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(-45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm2->SetTransform(this->transform * t);
            arm2->Render(camera);

            float heightOffset = 0.1f;
            float offset = 3.0f * 0.35f;
            propeller1->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, -offset)));
            propeller2->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, offset)));
            propeller3->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, -offset)));
            propeller4->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, offset)));

            propeller1->Render(camera);
            propeller2->Render(camera);
            propeller3->Render(camera);
            propeller4->Render(camera);
        }

        glm::vec3 GetYPR()
        {
            glm::mat4 R = glm::toMat4(orientation);

            float pitch = std::asin(-R[2][1]);
            float yaw = std::atan2(R[2][0], R[2][2]);
            float roll = std::atan2(R[0][1], R[1][1]);

            return glm::vec3(yaw, pitch, roll);
        }

        glm::quat FromEulerAngles(float yaw, float pitch, float roll)
        {
            glm::quat q_yaw = glm::angleAxis(yaw, glm::vec3(0, 1, 0));
            glm::quat q_pitch = glm::angleAxis(pitch, glm::vec3(1, 0, 0));
            glm::quat q_roll = glm::angleAxis(roll, glm::vec3(0, 0, 1));

            glm::quat newOrientation = q_yaw * q_pitch * q_roll;
            return glm::normalize(newOrientation);
        }

        // Rotate the drone around its local x axis (pitch)
        void RotatePitch(float deltaAngle)
        {
            glm::vec3 ypr = GetYPR();
            float yaw = ypr.x;
            float pitch = ypr.y;
            float roll = ypr.z;

            // Adjust and clamp pitch
            pitch += deltaAngle;
            pitch = glm::clamp(pitch, -glm::radians(20.0f), glm::radians(20.0f));

            orientation = FromEulerAngles(yaw, pitch, roll);
        }

        // Rotate the drone around its local y axis (yaw)
        void RotateYaw(float deltaAngle)
        {
            if (rolling || pitching)
                return;
            glm::vec3 ypr = GetYPR();
            float yaw = ypr.x;
            float pitch = ypr.y;
            float roll = ypr.z;

            // Yaw is unconstrained
            yaw += deltaAngle;

            orientation = FromEulerAngles(yaw, pitch, roll);
        }

        // Rotate the drone around its local z axis (roll)
        void RotateRoll(float deltaAngle)
        {
            glm::vec3 ypr = GetYPR();
            float yaw = ypr.x;
            float pitch = ypr.y;
            float roll = ypr.z;

            // Adjust and clamp roll
            roll += deltaAngle;
            roll = glm::clamp(roll, -glm::radians(20.0f), glm::radians(20.0f));

            orientation = FromEulerAngles(yaw, pitch, roll);
        }

        void ResetRotation()
        {
            orientation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f);
        }

        glm::vec3 pos = glm::vec3(0.0f), vel = glm::vec3(0.0f);
        std::unordered_map<std::string, glm::vec3> activeForces;

        float gravity = 200.0f;

        float motor1Thrust;
        float motor2Thrust;
        float motor3Thrust;
        float motor4Thrust;

        int verticalDirection = 0;

        bool rolling = false;
        bool pitching = false;
        bool yawing = false;
        
        PIDController *rollC, *pitchC;

    private:
        std::string name;
        Shader *shader;

        RectangularPrism *minimapIndicator;

        glm::mat4 transform = glm::mat4(1.0f);
        glm::quat orientation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f);

        Propeller *propeller1, *propeller2, *propeller3, *propeller4;
        RectangularPrism *body, *arm1, *arm2;
        float mass = 1.0f;
    };
}