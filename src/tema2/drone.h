#pragma once

#include "tema2/propeller.h"

#include <unordered_map>

namespace tema2
{
    class Drone
    {

    public:
        Drone(std::string name, Shader *shader)
            : name(name), shader(shader)
        {
            // Body: RectangularPrism with a squished Sphere
            body = new RectangularPrism(name + "_body", shader);
            body->ComputeMesh();
            body->SetColor(glm::vec3(0.3f));

            // Arms: Two perpendicular RectangularPrisms
            arm1 = new RectangularPrism(name + "_arm1", shader);
            arm1->ComputeMesh();
            arm1->SetColor(glm::vec3(0.7f));

            arm2 = new RectangularPrism(name + "_arm2", shader);
            arm2->ComputeMesh();
            arm2->SetColor(glm::vec3(0.7f));

            // Propellers at the ends of the arms
            propeller1 = new Propeller(name + "_propeller1", shader);
            propeller2 = new Propeller(name + "_propeller2", shader);
            propeller3 = new Propeller(name + "_propeller3", shader);
            propeller4 = new Propeller(name + "_propeller4", shader);

            activeForces["Gravity"] = glm::vec3(0.0f, -4.0f, 0.0f);
        }

        ~Drone()
        {
            delete body;
            delete arm1;
            delete arm2;
            delete propeller1;
            delete propeller2;
            delete propeller3;
            delete propeller4;
        }

        inline glm::mat3 eulerToRot(float roll, float pitch, float yaw)
        {
            glm::mat4 R_x = glm::rotate(glm::mat4(1.0f), roll, glm::vec3(1.0f, 0.0f, 0.0f));
            glm::mat4 R_y = glm::rotate(glm::mat4(1.0f), pitch, glm::vec3(0.0f, 1.0f, 0.0f));
            glm::mat4 R_z = glm::rotate(glm::mat4(1.0f), yaw, glm::vec3(0.0f, 0.0f, 1.0f));

            return R_z * R_y * R_x;
        }

        glm::vec3 computeMotorForces()
        {
            glm::vec3 forces = glm::vec3(0, motor1Thrust + motor2Thrust + motor3Thrust + motor4Thrust, 0);
            return eulerToRot(rot.x, rot.y, rot.z) * forces;
        }

        void Update(float deltaTimeSeconds)
        {
            // Compute the thrust needed to hover against gravity, EVEN WHEN NOT LEVELED OFF
            float hoverThrustNeeded = (mass * gravity) / (std::cos(rot.x) * std::cos(rot.z));
            float totalCurrentThrust = motor1Thrust + motor2Thrust + motor3Thrust + motor4Thrust;
            float scale = hoverThrustNeeded / totalCurrentThrust;

            motor1Thrust *= scale;
            motor2Thrust *= scale;
            motor3Thrust *= scale;
            motor4Thrust *= scale;

            // Compute the force generated by the motors
            glm::vec3 motorForce = computeMotorForces();

            activeForces["MotorForces"] = motorForce;

            glm::vec3 netForce = glm::vec3(0.0f);
            for (auto f : activeForces)
                netForce += f.second;

            glm::vec3 acc = netForce / mass;
            vel += acc * deltaTimeSeconds;
            pos += vel * deltaTimeSeconds;

            propeller1->Update(deltaTimeSeconds);
            propeller2->Update(deltaTimeSeconds);
            propeller3->Update(deltaTimeSeconds);
            propeller4->Update(deltaTimeSeconds);
        }

        void Render(gfxc::Camera *camera)
        {
            transform = glm::translate(glm::mat4(1.0f), pos);
            transform = glm::rotate(transform, rot.x, glm::vec3(1.0f, 0.0f, 0.0f));
            transform = glm::rotate(transform, rot.y, glm::vec3(0.0f, 1.0f, 0.0f));
            transform = glm::rotate(transform, rot.z, glm::vec3(0.0f, 0.0f, 1.0f));

            // Render body components
            body->SetTransform(this->transform * glm::scale(glm::mat4(1.0f), glm::vec3(1.0f, 0.5f, 0.7f)));
            body->Render(camera);

            // // Render arms
            glm::mat4 t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm1->SetTransform(this->transform * t);
            arm1->Render(camera);

            t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(-45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm2->SetTransform(this->transform * t);
            arm2->Render(camera);

            // Render propellers
            float heightOffset = 0.1f;
            float offset = 3.0f * 0.35f;
            propeller1->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, -offset)));
            propeller2->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, offset)));
            propeller3->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, -offset)));
            propeller4->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, offset)));

            propeller1->Render(camera);
            propeller2->Render(camera);
            propeller3->Render(camera);
            propeller4->Render(camera);
        }
        glm::vec3 pos = glm::vec3(0.0f), rot = glm::vec3(0.0f), vel = glm::vec3(0.0f);
        std::unordered_map<std::string, glm::vec3> activeForces;

        float motor1Thrust = 1.0f;
        float motor2Thrust = 1.0f;
        float motor3Thrust = 1.0f;
        float motor4Thrust = 1.0f;

    private:
        std::string name;
        Shader *shader;

        glm::mat4 transform = glm::mat4(1.0f);

        Propeller *propeller1, *propeller2, *propeller3, *propeller4;
        RectangularPrism *body, *arm1, *arm2;
        float mass = 1.0f;
        float gravity = 4.0f;
    };
}