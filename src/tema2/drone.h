#pragma once

#include "tema2/propeller.h"

#include <unordered_map>

namespace tema2
{
    class Drone
    {

    public:
        Drone(std::string name, Shader *shader)
            : name(name), shader(shader)
        {
            // Body: RectangularPrism with a squished Sphere
            body = new RectangularPrism(name + "_body", shader);
            body->ComputeMesh();
            body->SetColor(glm::vec3(0.3f));

            // Arms: Two perpendicular RectangularPrisms
            arm1 = new RectangularPrism(name + "_arm1", shader);
            arm1->ComputeMesh();
            arm1->SetColor(glm::vec3(0.7f));

            arm2 = new RectangularPrism(name + "_arm2", shader);
            arm2->ComputeMesh();
            arm2->SetColor(glm::vec3(0.7f));

            // Propellers at the ends of the arms
            propeller1 = new Propeller(name + "_propeller1", shader);
            propeller2 = new Propeller(name + "_propeller2", shader);
            propeller3 = new Propeller(name + "_propeller3", shader);
            propeller4 = new Propeller(name + "_propeller4", shader);

            activeForces["Gravity"] = glm::vec3(0.0f, -gravity, 0.0f);
        }

        ~Drone()
        {
            delete body;
            delete arm1;
            delete arm2;
            delete propeller1;
            delete propeller2;
            delete propeller3;
            delete propeller4;
        }

        inline glm::mat3 eulerToRot(float roll, float pitch, float yaw)
        {
            glm::mat4 R_x = glm::rotate(glm::mat4(1.0f), roll, glm::vec3(1.0f, 0.0f, 0.0f));
            glm::mat4 R_y = glm::rotate(glm::mat4(1.0f), pitch, glm::vec3(0.0f, 1.0f, 0.0f));
            glm::mat4 R_z = glm::rotate(glm::mat4(1.0f), yaw, glm::vec3(0.0f, 0.0f, 1.0f));

            return R_z * R_y * R_x;
        }

        glm::vec3 computeMotorForces()
        {
            // Compute total thrust from all motors
            float totalThrust = motor1Thrust + motor2Thrust + motor3Thrust + motor4Thrust;

            // Get the local up direction of the drone (assumes initial up direction is +Y)
            glm::vec3 localUp = eulerToRot(rot.x, rot.y, rot.z) * glm::vec3(0, 1, 0);

            // Compute the thrust force in the world space
            glm::vec3 forces = totalThrust * localUp;

            return forces;
        }

        void Update(float deltaTimeSeconds)
        {
            // Compute the thrust needed to hover against gravity, EVEN WHEN NOT LEVELED OFF
            // float hoverThrustNeeded = (mass * gravity) / (std::cos(rot.x) * std::cos(rot.z));
            // float totalCurrentThrust = motor1Thrust + motor2Thrust + motor3Thrust + motor4Thrust;
            // float scale = hoverThrustNeeded / totalCurrentThrust;

            // motor1Thrust *= scale;
            // motor2Thrust *= scale;
            // motor3Thrust *= scale;
            // motor4Thrust *= scale;

            // Compute the force generated by the motors
            glm::vec3 motorForce = computeMotorForces();

            std::cout << motorForce << "\n";

            activeForces["MotorForces"] = motorForce;
            activeForces["Drag"] = -vel * 80.0f * deltaTimeSeconds;

            glm::vec3 netForce = glm::vec3(0.0f);
            for (auto f : activeForces)
                netForce += f.second;

            glm::vec3 acc = netForce / mass;
            // vel += acc * deltaTimeSeconds;
            // pos += vel * deltaTimeSeconds;

            glm::vec3 k1_vel = acc * deltaTimeSeconds;
            glm::vec3 k1_pos = vel * deltaTimeSeconds;

            glm::vec3 k2_vel = (acc + 0.5f * k1_vel) * deltaTimeSeconds;
            glm::vec3 k2_pos = (vel + 0.5f * k1_pos) * deltaTimeSeconds;

            glm::vec3 k3_vel = (acc + 0.5f * k2_vel) * deltaTimeSeconds;
            glm::vec3 k3_pos = (vel + 0.5f * k2_pos) * deltaTimeSeconds;

            glm::vec3 k4_vel = (acc + k3_vel) * deltaTimeSeconds;
            glm::vec3 k4_pos = (vel + k3_pos) * deltaTimeSeconds;

            vel += (1.0f / 6.0f) * (k1_vel + 2.0f * k2_vel + 2.0f * k3_vel + k4_vel);
            pos += (1.0f / 6.0f) * (k1_pos + 2.0f * k2_pos + 2.0f * k3_pos + k4_pos);

            propeller1->Update(deltaTimeSeconds);
            propeller2->Update(deltaTimeSeconds);
            propeller3->Update(deltaTimeSeconds);
            propeller4->Update(deltaTimeSeconds);
        }

        void Render(gfxc::Camera *camera)
        {
            transform = glm::translate(glm::mat4(1.0f), pos);
            transform = glm::rotate(transform, rot.x, glm::vec3(1.0f, 0.0f, 0.0f));
            transform = glm::rotate(transform, rot.y, glm::vec3(0.0f, 1.0f, 0.0f));
            transform = glm::rotate(transform, rot.z, glm::vec3(0.0f, 0.0f, 1.0f));

            // Render body components
            body->SetTransform(this->transform * glm::scale(glm::mat4(1.0f), glm::vec3(1.0f, 0.5f, 0.7f)));
            body->Render(camera);

            // // Render arms
            glm::mat4 t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm1->SetTransform(this->transform * t);
            arm1->Render(camera);

            t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(-45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm2->SetTransform(this->transform * t);
            arm2->Render(camera);

            // Render propellers
            float heightOffset = 0.1f;
            float offset = 3.0f * 0.35f;
            propeller1->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, -offset)));
            propeller2->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, offset)));
            propeller3->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, -offset)));
            propeller4->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, offset)));

            propeller1->Render(camera);
            propeller2->Render(camera);
            propeller3->Render(camera);
            propeller4->Render(camera);
        }
        glm::vec3 pos = glm::vec3(0.0f), rot = glm::vec3(0.0f), vel = glm::vec3(0.0f);
        std::unordered_map<std::string, glm::vec3> activeForces;

        float gravity = 70.0f;
        float hoverThrust = gravity / 4.0f;

        float motor1Thrust = hoverThrust;
        float motor2Thrust = hoverThrust;
        float motor3Thrust = hoverThrust;
        float motor4Thrust = hoverThrust;
        float maxThrust = hoverThrust * 1.0f;

    private:
        std::string name;
        Shader *shader;

        glm::mat4 transform = glm::mat4(1.0f);

        Propeller *propeller1, *propeller2, *propeller3, *propeller4;
        RectangularPrism *body, *arm1, *arm2;
        float mass = 1.0f;
    };
}