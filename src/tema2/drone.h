#pragma once

#include "tema2/propeller.h"
#include "tema2/utils/pidcontroller.h"

#include <unordered_map>

namespace tema2
{
    class Drone
    {

    public:
        Drone(std::string name, Shader *shader)
            : name(name), shader(shader)
        {
            // Body: RectangularPrism with a squished Sphere
            body = new RectangularPrism(name + "_body", shader);
            body->ComputeMesh();
            body->SetColor(glm::vec3(0.3f));

            // Arms: Two perpendicular RectangularPrisms
            arm1 = new RectangularPrism(name + "_arm1", shader);
            arm1->ComputeMesh();
            arm1->SetColor(glm::vec3(0.7f));

            arm2 = new RectangularPrism(name + "_arm2", shader);
            arm2->ComputeMesh();
            arm2->SetColor(glm::vec3(0.7f));

            // Propellers at the ends of the arms
            propeller1 = new Propeller(name + "_propeller1", shader);
            propeller2 = new Propeller(name + "_propeller2", shader);
            propeller3 = new Propeller(name + "_propeller3", shader);
            propeller4 = new Propeller(name + "_propeller4", shader);

            activeForces["Gravity"] = glm::vec3(0.0f, -gravity, 0.0f);

            rollC = new PIDController(5.0f, 0.0f, 0.0f, 0.0f);
            pitchC = new PIDController(5.0f, 0.0f, 0.0f, 0.0f);
        }

        ~Drone()
        {
            delete body;
            delete arm1;
            delete arm2;
            delete propeller1;
            delete propeller2;
            delete propeller3;
            delete propeller4;
        }

        glm::vec3 computeMotorForces()
        {
            float totalThrust = motor1Thrust + motor2Thrust + motor3Thrust + motor4Thrust;

            // Transform the local up vector (0, 1, 0) using the quaternion
            glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
            glm::vec3 thrustDirection = orientation * up;

            // Compute the motor forces in the global direction
            return totalThrust * thrustDirection;
        }

        void Update(float deltaTimeSeconds)
        {
            // Compute the thrust needed to hover against gravity, EVEN WHEN NOT LEVELED OFF
            glm::vec3 angles = glm::eulerAngles(orientation);
            float hoverThrustNeeded = (mass * gravity) / (std::cos(angles.x) * std::cos(angles.z));
            motor1Thrust = hoverThrustNeeded / 4.0f;
            motor2Thrust = hoverThrustNeeded / 4.0f;
            motor3Thrust = hoverThrustNeeded / 4.0f;
            motor4Thrust = hoverThrustNeeded / 4.0f;

            // std::cout << angles << "\n";

            // If we are going up or down, give some extra thrust
            float extraThrust = (hoverThrustNeeded / 4.0f) * 0.10f;
            motor1Thrust += extraThrust * verticalDirection;
            motor2Thrust += extraThrust * verticalDirection;
            motor3Thrust += extraThrust * verticalDirection;
            motor4Thrust += extraThrust * verticalDirection;

            // Compute the force generated by the motors
            glm::vec3 motorForce = computeMotorForces();

            // std::cout << motorForce << "\n";
            // std::cout << yawing << "\n";

            activeForces["MotorForces"] = motorForce;
            // activeForces["MotorForces"] = glm::vec3(0.0, gravity, 0.0);
            activeForces["Drag"] = -vel * 200.0f * deltaTimeSeconds;

            glm::vec3 netForce = glm::vec3(0.0f);
            for (auto f : activeForces)
                netForce += f.second;

            glm::vec3 acc = netForce / mass;

            glm::vec3 k1_vel = acc * deltaTimeSeconds;
            glm::vec3 k1_pos = vel * deltaTimeSeconds;

            glm::vec3 k2_vel = (acc + 0.5f * k1_vel) * deltaTimeSeconds;
            glm::vec3 k2_pos = (vel + 0.5f * k1_pos) * deltaTimeSeconds;

            glm::vec3 k3_vel = (acc + 0.5f * k2_vel) * deltaTimeSeconds;
            glm::vec3 k3_pos = (vel + 0.5f * k2_pos) * deltaTimeSeconds;

            glm::vec3 k4_vel = (acc + k3_vel) * deltaTimeSeconds;
            glm::vec3 k4_pos = (vel + k3_pos) * deltaTimeSeconds;

            vel += (1.0f / 6.0f) * (k1_vel + 2.0f * k2_vel + 2.0f * k3_vel + k4_vel);
            pos += (1.0f / 6.0f) * (k1_pos + 2.0f * k2_pos + 2.0f * k3_pos + k4_pos);

            propeller1->Update(deltaTimeSeconds);
            propeller2->Update(deltaTimeSeconds);
            propeller3->Update(deltaTimeSeconds);
            propeller4->Update(deltaTimeSeconds);

            if (!rolling)
            {
                float correction = rollC->update(getEulerAngles().z);
                if (fabs(correction) > 0.01f)
                {
                    RotateRoll(correction);
                }
            }

            if (!pitching)
            {
                float correction = pitchC->update(getEulerAngles().x);
                if (fabs(correction) > 0.01f)
                {
                    RotatePitch(correction);
                }
            }
        }

        void Render(gfxc::Camera *camera)
        {
            transform = glm::translate(glm::mat4(1.0f), pos);
            transform *= glm::toMat4(orientation);

            // Render body components
            body->SetTransform(this->transform * glm::scale(glm::mat4(1.0f), glm::vec3(0.7f, 0.5f, 1.0f)));
            body->Render(camera);

            // Render arms
            glm::mat4 t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm1->SetTransform(this->transform * t);
            arm1->Render(camera);

            t = glm::mat4(1.0f);
            t = glm::rotate(t, glm::radians(-45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
            t = glm::scale(t, glm::vec3(3.0f, 0.1f, 0.1f));
            arm2->SetTransform(this->transform * t);
            arm2->Render(camera);

            // Render propellers
            float heightOffset = 0.1f;
            float offset = 3.0f * 0.35f;
            propeller1->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, -offset)));
            propeller2->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(offset, heightOffset, offset)));
            propeller3->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, -offset)));
            propeller4->SetTransform(this->transform * glm::translate(glm::mat4(1.0f), glm::vec3(-offset, heightOffset, offset)));

            propeller1->Render(camera);
            propeller2->Render(camera);
            propeller3->Render(camera);
            propeller4->Render(camera);
        }

        // Rotate the drone around its local x axis (pitch)
        void RotatePitch(float angle)
        {
            // Get the forward vector in global space
            glm::vec3 forward = orientation * glm::vec3(0.0f, 0.0f, -1.0f);

            // Calculate the current pitch angle (angle between forward and horizontal plane)
            float currentPitch = glm::degrees(glm::asin(forward.y)); // Only works reliably if forward.y is small

            // Check if the pitch angle is within the limits
            if ((currentPitch > 20.0f && angle > 0) || (currentPitch < -20.0f && angle < 0))
                return;

            // Rotate around the local X-axis
            glm::vec3 localXAxis = orientation * glm::vec3(1.0f, 0.0f, 0.0f);
            glm::quat pitchRotation = glm::angleAxis(glm::radians(angle), localXAxis);

            // Apply the pitch rotation
            orientation = pitchRotation * orientation;
        }

        // Rotate the drone around its local y axis (yaw)
        void RotateYaw(float angle)
        {
            if (rolling || pitching)
                return;
            // Rotate around the local Y-axis
            glm::vec3 localYAxis = orientation * glm::vec3(0.0f, 1.0f, 0.0f);
            glm::quat yawRotation = glm::angleAxis(glm::radians(angle), localYAxis);

            // Apply the yaw rotation
            orientation = yawRotation * orientation;
        }

        // Rotate the drone around its local z axis (roll)
        void RotateRoll(float angle)
        {
            // Get the up vector in global space
            glm::vec3 up = orientation * glm::vec3(0.0f, 1.0f, 0.0f);

            // Calculate roll angle (dot product or approximation of tilt)
            float currentRoll = glm::degrees(glm::atan(up.x, up.y)); // Roll relative to the global XY-plane
            // std::cout << currentRoll << "\n";
            // Check if the roll angle is within the limits
            if ((currentRoll > 20.0f && angle < 0) || (currentRoll < -20.0f && angle > 0))
                return;

            // Rotate around the local Z-axis
            glm::vec3 localZAxis = orientation * glm::vec3(0.0f, 0.0f, 1.0f);
            glm::quat rollRotation = glm::angleAxis(glm::radians(angle), localZAxis);

            // Apply the roll rotation
            orientation = rollRotation * orientation;
        }

        void ResetRotation()
        {
            orientation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f);
        }

        glm::vec3 getEulerAngles()
        {
            return glm::eulerAngles(orientation);
        }

        glm::vec3 pos = glm::vec3(0.0f), vel = glm::vec3(0.0f);
        std::unordered_map<std::string, glm::vec3> activeForces;

        float gravity = 80.0f;

        float motor1Thrust;
        float motor2Thrust;
        float motor3Thrust;
        float motor4Thrust;

        int verticalDirection = 0;

        bool rolling = false;
        bool pitching = false;
        bool yawing = false;
        PIDController *rollC, *pitchC;

    private:
        std::string name;
        Shader *shader;

        glm::mat4 transform = glm::mat4(1.0f);
        glm::quat orientation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f);

        Propeller *propeller1, *propeller2, *propeller3, *propeller4;
        RectangularPrism *body, *arm1, *arm2;
        float mass = 1.0f;
    };
}